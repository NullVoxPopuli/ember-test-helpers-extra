import Service from '@ember/service';
import { getContext } from '@ember/test-helpers';
export function getService(name) {
  const {
    owner
  } = getContext();
  const service = owner.lookup(`service:${name}`);
  return service;
}
export const stubService = (name, hash = {}) => {
  let stubbedService; // TODO: need to be able to use an extended service that uses services.

  if (hash instanceof Function) {
    stubbedService = hash;
  } else {
    stubbedService = Service.extend(hash);
  }

  let {
    owner
  } = getContext();
  let serviceName = `service:${name}`;
  owner.register(serviceName, stubbedService);
};
/**
 * Doing a normal service stub will NOT work in a beforeEach
 * or anywhere else in your test because (instance) initializers
 * run before *any* user-land code.
 *
 * https://github.com/ember-cli/ember-cli-qunit/issues/203#issuecomment-366261794
 *
 * @public
 * @param {NestedHooks} hooks module hooks for the test context
 * @param {string} name the name of the service
 * @param {object} stub the overrides to apply to the service
 **/

export function setupServiceStub(hooks, name, stub) {
  let serviceName = `service:${name}`;
  let originals = {};
  hooks.beforeEach(function () {
    let {
      owner
    } = getContext();
    let service = owner.lookup(serviceName);

    if (!service) {
      throw new Error(`service '${name}' was not registered. You do not need setupServiceStub`);
    }

    let propertiesAndMethods = Object.keys(stub);
    propertiesAndMethods.forEach(key => {
      originals[key] = service[key];
      service[key] = stub[key];
    });
  });
  hooks.afterEach(function () {
    let {
      owner
    } = getContext();
    let service = owner.lookup(serviceName);
    let propertiesAndMethods = Object.keys(stub);
    propertiesAndMethods.forEach(key => {
      service[key] = originals[key];
    });
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9oZWxwZXJzL3NlcnZpY2VzLnRzIl0sIm5hbWVzIjpbIlNlcnZpY2UiLCJnZXRDb250ZXh0IiwiZ2V0U2VydmljZSIsIm5hbWUiLCJvd25lciIsInNlcnZpY2UiLCJsb29rdXAiLCJzdHViU2VydmljZSIsImhhc2giLCJzdHViYmVkU2VydmljZSIsIkZ1bmN0aW9uIiwiZXh0ZW5kIiwic2VydmljZU5hbWUiLCJyZWdpc3RlciIsInNldHVwU2VydmljZVN0dWIiLCJob29rcyIsInN0dWIiLCJvcmlnaW5hbHMiLCJiZWZvcmVFYWNoIiwiRXJyb3IiLCJwcm9wZXJ0aWVzQW5kTWV0aG9kcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiYWZ0ZXJFYWNoIl0sIm1hcHBpbmdzIjoiQUFBQSxPQUFPQSxPQUFQLE1BQW9CLGdCQUFwQjtBQUNBLFNBQVNDLFVBQVQsUUFBMkIscUJBQTNCO0FBT0EsT0FBTyxTQUFTQyxVQUFULENBQXVCQyxJQUF2QixFQUF3QztBQUM3QyxRQUFNO0FBQUVDLElBQUFBO0FBQUYsTUFBWUgsVUFBVSxFQUE1QjtBQUVBLFFBQU1JLE9BQU8sR0FBR0QsS0FBSyxDQUFDRSxNQUFOLENBQWMsV0FBVUgsSUFBSyxFQUE3QixDQUFoQjtBQUVBLFNBQU9FLE9BQVA7QUFDRDtBQUVELE9BQU8sTUFBTUUsV0FBVyxHQUFHLENBQUNKLElBQUQsRUFBZUssSUFBSSxHQUFHLEVBQXRCLEtBQW1DO0FBQzVELE1BQUlDLGNBQUosQ0FENEQsQ0FHNUQ7O0FBQ0EsTUFBSUQsSUFBSSxZQUFZRSxRQUFwQixFQUE4QjtBQUM1QkQsSUFBQUEsY0FBYyxHQUFHRCxJQUFqQjtBQUNELEdBRkQsTUFFTztBQUNMQyxJQUFBQSxjQUFjLEdBQUdULE9BQU8sQ0FBQ1csTUFBUixDQUFlSCxJQUFmLENBQWpCO0FBQ0Q7O0FBRUQsTUFBSTtBQUFFSixJQUFBQTtBQUFGLE1BQVlILFVBQVUsRUFBMUI7QUFDQSxNQUFJVyxXQUFXLEdBQUksV0FBVVQsSUFBSyxFQUFsQztBQUVBQyxFQUFBQSxLQUFLLENBQUNTLFFBQU4sQ0FBZUQsV0FBZixFQUE0QkgsY0FBNUI7QUFDRCxDQWRNO0FBZ0JQOzs7Ozs7Ozs7Ozs7O0FBWUEsT0FBTyxTQUFTSyxnQkFBVCxDQUNMQyxLQURLLEVBRUxaLElBRkssRUFHTGEsSUFISyxFQUlDO0FBQ04sTUFBSUosV0FBVyxHQUFJLFdBQVVULElBQUssRUFBbEM7QUFDQSxNQUFJYyxTQUFjLEdBQUcsRUFBckI7QUFFQUYsRUFBQUEsS0FBSyxDQUFDRyxVQUFOLENBQWlCLFlBQWlCO0FBQ2hDLFFBQUk7QUFBRWQsTUFBQUE7QUFBRixRQUFZSCxVQUFVLEVBQTFCO0FBQ0EsUUFBSUksT0FBTyxHQUFHRCxLQUFLLENBQUNFLE1BQU4sQ0FBYU0sV0FBYixDQUFkOztBQUVBLFFBQUksQ0FBQ1AsT0FBTCxFQUFjO0FBQ1osWUFBTSxJQUFJYyxLQUFKLENBQ0gsWUFBV2hCLElBQUssd0RBRGIsQ0FBTjtBQUdEOztBQUVELFFBQUlpQixvQkFBb0IsR0FBR0MsTUFBTSxDQUFDQyxJQUFQLENBQVlOLElBQVosQ0FBM0I7QUFFQUksSUFBQUEsb0JBQW9CLENBQUNHLE9BQXJCLENBQStCQyxHQUFGLElBQWlCO0FBQzVDUCxNQUFBQSxTQUFTLENBQUNPLEdBQUQsQ0FBVCxHQUFpQm5CLE9BQU8sQ0FBQ21CLEdBQUQsQ0FBeEI7QUFFQW5CLE1BQUFBLE9BQU8sQ0FBQ21CLEdBQUQsQ0FBUCxHQUFlUixJQUFJLENBQUNRLEdBQUQsQ0FBbkI7QUFDRCxLQUpEO0FBS0QsR0FqQkQ7QUFtQkFULEVBQUFBLEtBQUssQ0FBQ1UsU0FBTixDQUFnQixZQUFpQjtBQUMvQixRQUFJO0FBQUVyQixNQUFBQTtBQUFGLFFBQVlILFVBQVUsRUFBMUI7QUFDQSxRQUFJSSxPQUFPLEdBQUdELEtBQUssQ0FBQ0UsTUFBTixDQUFhTSxXQUFiLENBQWQ7QUFFQSxRQUFJUSxvQkFBb0IsR0FBR0MsTUFBTSxDQUFDQyxJQUFQLENBQVlOLElBQVosQ0FBM0I7QUFFQUksSUFBQUEsb0JBQW9CLENBQUNHLE9BQXJCLENBQStCQyxHQUFGLElBQWlCO0FBQzVDbkIsTUFBQUEsT0FBTyxDQUFDbUIsR0FBRCxDQUFQLEdBQWVQLFNBQVMsQ0FBQ08sR0FBRCxDQUF4QjtBQUNELEtBRkQ7QUFHRCxHQVREO0FBVUQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU2VydmljZSBmcm9tICdAZW1iZXIvc2VydmljZSc7XG5pbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnQGVtYmVyL3Rlc3QtaGVscGVycyc7XG5pbXBvcnQgQXBwbGljYXRpb25JbnN0YW5jZSBmcm9tICdAZW1iZXIvYXBwbGljYXRpb24vaW5zdGFuY2UnO1xuXG5pbnRlcmZhY2UgQ29udGV4dCB7XG4gIG93bmVyOiBBcHBsaWNhdGlvbkluc3RhbmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VydmljZTxUPihuYW1lOiBzdHJpbmcpOiBUIHtcbiAgY29uc3QgeyBvd25lciB9ID0gZ2V0Q29udGV4dCgpIGFzIENvbnRleHQ7XG5cbiAgY29uc3Qgc2VydmljZSA9IG93bmVyLmxvb2t1cChgc2VydmljZToke25hbWV9YCk7XG5cbiAgcmV0dXJuIHNlcnZpY2UgYXMgVDtcbn1cblxuZXhwb3J0IGNvbnN0IHN0dWJTZXJ2aWNlID0gKG5hbWU6IHN0cmluZywgaGFzaCA9IHt9KTogdm9pZCA9PiB7XG4gIGxldCBzdHViYmVkU2VydmljZTtcblxuICAvLyBUT0RPOiBuZWVkIHRvIGJlIGFibGUgdG8gdXNlIGFuIGV4dGVuZGVkIHNlcnZpY2UgdGhhdCB1c2VzIHNlcnZpY2VzLlxuICBpZiAoaGFzaCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgc3R1YmJlZFNlcnZpY2UgPSBoYXNoO1xuICB9IGVsc2Uge1xuICAgIHN0dWJiZWRTZXJ2aWNlID0gU2VydmljZS5leHRlbmQoaGFzaCk7XG4gIH1cblxuICBsZXQgeyBvd25lciB9ID0gZ2V0Q29udGV4dCgpIGFzIENvbnRleHQ7XG4gIGxldCBzZXJ2aWNlTmFtZSA9IGBzZXJ2aWNlOiR7bmFtZX1gO1xuXG4gIG93bmVyLnJlZ2lzdGVyKHNlcnZpY2VOYW1lLCBzdHViYmVkU2VydmljZSk7XG59O1xuXG4vKipcbiAqIERvaW5nIGEgbm9ybWFsIHNlcnZpY2Ugc3R1YiB3aWxsIE5PVCB3b3JrIGluIGEgYmVmb3JlRWFjaFxuICogb3IgYW55d2hlcmUgZWxzZSBpbiB5b3VyIHRlc3QgYmVjYXVzZSAoaW5zdGFuY2UpIGluaXRpYWxpemVyc1xuICogcnVuIGJlZm9yZSAqYW55KiB1c2VyLWxhbmQgY29kZS5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZW1iZXItY2xpL2VtYmVyLWNsaS1xdW5pdC9pc3N1ZXMvMjAzI2lzc3VlY29tbWVudC0zNjYyNjE3OTRcbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge05lc3RlZEhvb2tzfSBob29rcyBtb2R1bGUgaG9va3MgZm9yIHRoZSB0ZXN0IGNvbnRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBzZXJ2aWNlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R1YiB0aGUgb3ZlcnJpZGVzIHRvIGFwcGx5IHRvIHRoZSBzZXJ2aWNlXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBTZXJ2aWNlU3R1YihcbiAgaG9va3M6IE5lc3RlZEhvb2tzLFxuICBuYW1lOiBzdHJpbmcsXG4gIHN0dWI6IFJlY29yZDxzdHJpbmcsIGFueT5cbik6IHZvaWQge1xuICBsZXQgc2VydmljZU5hbWUgPSBgc2VydmljZToke25hbWV9YDtcbiAgbGV0IG9yaWdpbmFsczogYW55ID0ge307XG5cbiAgaG9va3MuYmVmb3JlRWFjaChmdW5jdGlvbigpOiB2b2lkIHtcbiAgICBsZXQgeyBvd25lciB9ID0gZ2V0Q29udGV4dCgpIGFzIENvbnRleHQ7XG4gICAgbGV0IHNlcnZpY2UgPSBvd25lci5sb29rdXAoc2VydmljZU5hbWUpO1xuXG4gICAgaWYgKCFzZXJ2aWNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBzZXJ2aWNlICcke25hbWV9JyB3YXMgbm90IHJlZ2lzdGVyZWQuIFlvdSBkbyBub3QgbmVlZCBzZXR1cFNlcnZpY2VTdHViYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgcHJvcGVydGllc0FuZE1ldGhvZHMgPSBPYmplY3Qua2V5cyhzdHViKTtcblxuICAgIHByb3BlcnRpZXNBbmRNZXRob2RzLmZvckVhY2goKCBrZXkgKTogdm9pZCA9PiB7XG4gICAgICBvcmlnaW5hbHNba2V5XSA9IHNlcnZpY2Vba2V5XTtcblxuICAgICAgc2VydmljZVtrZXldID0gc3R1YltrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICBob29rcy5hZnRlckVhY2goZnVuY3Rpb24oKTogdm9pZCB7XG4gICAgbGV0IHsgb3duZXIgfSA9IGdldENvbnRleHQoKSBhcyBDb250ZXh0O1xuICAgIGxldCBzZXJ2aWNlID0gb3duZXIubG9va3VwKHNlcnZpY2VOYW1lKTtcblxuICAgIGxldCBwcm9wZXJ0aWVzQW5kTWV0aG9kcyA9IE9iamVjdC5rZXlzKHN0dWIpO1xuXG4gICAgcHJvcGVydGllc0FuZE1ldGhvZHMuZm9yRWFjaCgoIGtleSApOiB2b2lkID0+IHtcbiAgICAgIHNlcnZpY2Vba2V5XSA9IG9yaWdpbmFsc1trZXldO1xuICAgIH0pO1xuICB9KTtcbn1cbiJdfQ==