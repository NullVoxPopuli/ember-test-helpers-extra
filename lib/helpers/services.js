"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getService = getService;
exports.setupServiceStub = setupServiceStub;
exports.stubService = void 0;

var _service = _interopRequireDefault(require("@ember/service"));

var _testHelpers = require("@ember/test-helpers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getService(name) {
  const {
    owner
  } = (0, _testHelpers.getContext)();
  const service = owner.lookup(`service:${name}`);
  return service;
}

const stubService = (name, hash = {}) => {
  let stubbedService; // TODO: need to be able to use an extended service that uses services.

  if (hash instanceof Function) {
    stubbedService = hash;
  } else {
    stubbedService = _service.default.extend(hash);
  }

  let {
    owner
  } = (0, _testHelpers.getContext)();
  let serviceName = `service:${name}`;
  owner.register(serviceName, stubbedService);
};
/**
 * Doing a normal service stub will NOT work in a beforeEach
 * or anywhere else in your test because (instance) initializers
 * run before *any* user-land code.
 *
 * https://github.com/ember-cli/ember-cli-qunit/issues/203#issuecomment-366261794
 *
 * @public
 * @param {NestedHooks} hooks module hooks for the test context
 * @param {string} name the name of the service
 * @param {object} stub the overrides to apply to the service
 **/


exports.stubService = stubService;

function setupServiceStub(hooks, name, stub) {
  let serviceName = `service:${name}`;
  let originals = {};
  hooks.beforeEach(function () {
    let {
      owner
    } = (0, _testHelpers.getContext)();
    let service = owner.lookup(serviceName);

    if (!service) {
      throw new Error(`service '${name}' was not registered. You do not need setupServiceStub`);
    }

    let propertiesAndMethods = Object.keys(stub);
    propertiesAndMethods.forEach(key => {
      originals[key] = service[key];
      service[key] = stub[key];
    });
  });
  hooks.afterEach(function () {
    let {
      owner
    } = (0, _testHelpers.getContext)();
    let service = owner.lookup(serviceName);
    let propertiesAndMethods = Object.keys(stub);
    propertiesAndMethods.forEach(key => {
      service[key] = originals[key];
    });
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9oZWxwZXJzL3NlcnZpY2VzLnRzIl0sIm5hbWVzIjpbImdldFNlcnZpY2UiLCJuYW1lIiwib3duZXIiLCJzZXJ2aWNlIiwibG9va3VwIiwic3R1YlNlcnZpY2UiLCJoYXNoIiwic3R1YmJlZFNlcnZpY2UiLCJGdW5jdGlvbiIsIlNlcnZpY2UiLCJleHRlbmQiLCJzZXJ2aWNlTmFtZSIsInJlZ2lzdGVyIiwic2V0dXBTZXJ2aWNlU3R1YiIsImhvb2tzIiwic3R1YiIsIm9yaWdpbmFscyIsImJlZm9yZUVhY2giLCJFcnJvciIsInByb3BlcnRpZXNBbmRNZXRob2RzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJhZnRlckVhY2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOzs7O0FBT08sU0FBU0EsVUFBVCxDQUF1QkMsSUFBdkIsRUFBd0M7QUFDN0MsUUFBTTtBQUFFQyxJQUFBQTtBQUFGLE1BQVksOEJBQWxCO0FBRUEsUUFBTUMsT0FBTyxHQUFHRCxLQUFLLENBQUNFLE1BQU4sQ0FBYyxXQUFVSCxJQUFLLEVBQTdCLENBQWhCO0FBRUEsU0FBT0UsT0FBUDtBQUNEOztBQUVNLE1BQU1FLFdBQVcsR0FBRyxDQUFDSixJQUFELEVBQWVLLElBQUksR0FBRyxFQUF0QixLQUFtQztBQUM1RCxNQUFJQyxjQUFKLENBRDRELENBRzVEOztBQUNBLE1BQUlELElBQUksWUFBWUUsUUFBcEIsRUFBOEI7QUFDNUJELElBQUFBLGNBQWMsR0FBR0QsSUFBakI7QUFDRCxHQUZELE1BRU87QUFDTEMsSUFBQUEsY0FBYyxHQUFHRSxpQkFBUUMsTUFBUixDQUFlSixJQUFmLENBQWpCO0FBQ0Q7O0FBRUQsTUFBSTtBQUFFSixJQUFBQTtBQUFGLE1BQVksOEJBQWhCO0FBQ0EsTUFBSVMsV0FBVyxHQUFJLFdBQVVWLElBQUssRUFBbEM7QUFFQUMsRUFBQUEsS0FBSyxDQUFDVSxRQUFOLENBQWVELFdBQWYsRUFBNEJKLGNBQTVCO0FBQ0QsQ0FkTTtBQWdCUDs7Ozs7Ozs7Ozs7Ozs7OztBQVlPLFNBQVNNLGdCQUFULENBQ0xDLEtBREssRUFFTGIsSUFGSyxFQUdMYyxJQUhLLEVBSUM7QUFDTixNQUFJSixXQUFXLEdBQUksV0FBVVYsSUFBSyxFQUFsQztBQUNBLE1BQUllLFNBQWMsR0FBRyxFQUFyQjtBQUVBRixFQUFBQSxLQUFLLENBQUNHLFVBQU4sQ0FBaUIsWUFBaUI7QUFDaEMsUUFBSTtBQUFFZixNQUFBQTtBQUFGLFFBQVksOEJBQWhCO0FBQ0EsUUFBSUMsT0FBTyxHQUFHRCxLQUFLLENBQUNFLE1BQU4sQ0FBYU8sV0FBYixDQUFkOztBQUVBLFFBQUksQ0FBQ1IsT0FBTCxFQUFjO0FBQ1osWUFBTSxJQUFJZSxLQUFKLENBQ0gsWUFBV2pCLElBQUssd0RBRGIsQ0FBTjtBQUdEOztBQUVELFFBQUlrQixvQkFBb0IsR0FBR0MsTUFBTSxDQUFDQyxJQUFQLENBQVlOLElBQVosQ0FBM0I7QUFFQUksSUFBQUEsb0JBQW9CLENBQUNHLE9BQXJCLENBQStCQyxHQUFGLElBQWlCO0FBQzVDUCxNQUFBQSxTQUFTLENBQUNPLEdBQUQsQ0FBVCxHQUFpQnBCLE9BQU8sQ0FBQ29CLEdBQUQsQ0FBeEI7QUFFQXBCLE1BQUFBLE9BQU8sQ0FBQ29CLEdBQUQsQ0FBUCxHQUFlUixJQUFJLENBQUNRLEdBQUQsQ0FBbkI7QUFDRCxLQUpEO0FBS0QsR0FqQkQ7QUFtQkFULEVBQUFBLEtBQUssQ0FBQ1UsU0FBTixDQUFnQixZQUFpQjtBQUMvQixRQUFJO0FBQUV0QixNQUFBQTtBQUFGLFFBQVksOEJBQWhCO0FBQ0EsUUFBSUMsT0FBTyxHQUFHRCxLQUFLLENBQUNFLE1BQU4sQ0FBYU8sV0FBYixDQUFkO0FBRUEsUUFBSVEsb0JBQW9CLEdBQUdDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZTixJQUFaLENBQTNCO0FBRUFJLElBQUFBLG9CQUFvQixDQUFDRyxPQUFyQixDQUErQkMsR0FBRixJQUFpQjtBQUM1Q3BCLE1BQUFBLE9BQU8sQ0FBQ29CLEdBQUQsQ0FBUCxHQUFlUCxTQUFTLENBQUNPLEdBQUQsQ0FBeEI7QUFDRCxLQUZEO0FBR0QsR0FURDtBQVVEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFNlcnZpY2UgZnJvbSAnQGVtYmVyL3NlcnZpY2UnO1xuaW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ0BlbWJlci90ZXN0LWhlbHBlcnMnO1xuaW1wb3J0IEFwcGxpY2F0aW9uSW5zdGFuY2UgZnJvbSAnQGVtYmVyL2FwcGxpY2F0aW9uL2luc3RhbmNlJztcblxuaW50ZXJmYWNlIENvbnRleHQge1xuICBvd25lcjogQXBwbGljYXRpb25JbnN0YW5jZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlcnZpY2U8VD4obmFtZTogc3RyaW5nKTogVCB7XG4gIGNvbnN0IHsgb3duZXIgfSA9IGdldENvbnRleHQoKSBhcyBDb250ZXh0O1xuXG4gIGNvbnN0IHNlcnZpY2UgPSBvd25lci5sb29rdXAoYHNlcnZpY2U6JHtuYW1lfWApO1xuXG4gIHJldHVybiBzZXJ2aWNlIGFzIFQ7XG59XG5cbmV4cG9ydCBjb25zdCBzdHViU2VydmljZSA9IChuYW1lOiBzdHJpbmcsIGhhc2ggPSB7fSk6IHZvaWQgPT4ge1xuICBsZXQgc3R1YmJlZFNlcnZpY2U7XG5cbiAgLy8gVE9ETzogbmVlZCB0byBiZSBhYmxlIHRvIHVzZSBhbiBleHRlbmRlZCBzZXJ2aWNlIHRoYXQgdXNlcyBzZXJ2aWNlcy5cbiAgaWYgKGhhc2ggaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHN0dWJiZWRTZXJ2aWNlID0gaGFzaDtcbiAgfSBlbHNlIHtcbiAgICBzdHViYmVkU2VydmljZSA9IFNlcnZpY2UuZXh0ZW5kKGhhc2gpO1xuICB9XG5cbiAgbGV0IHsgb3duZXIgfSA9IGdldENvbnRleHQoKSBhcyBDb250ZXh0O1xuICBsZXQgc2VydmljZU5hbWUgPSBgc2VydmljZToke25hbWV9YDtcblxuICBvd25lci5yZWdpc3RlcihzZXJ2aWNlTmFtZSwgc3R1YmJlZFNlcnZpY2UpO1xufTtcblxuLyoqXG4gKiBEb2luZyBhIG5vcm1hbCBzZXJ2aWNlIHN0dWIgd2lsbCBOT1Qgd29yayBpbiBhIGJlZm9yZUVhY2hcbiAqIG9yIGFueXdoZXJlIGVsc2UgaW4geW91ciB0ZXN0IGJlY2F1c2UgKGluc3RhbmNlKSBpbml0aWFsaXplcnNcbiAqIHJ1biBiZWZvcmUgKmFueSogdXNlci1sYW5kIGNvZGUuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2VtYmVyLWNsaS9lbWJlci1jbGktcXVuaXQvaXNzdWVzLzIwMyNpc3N1ZWNvbW1lbnQtMzY2MjYxNzk0XG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtOZXN0ZWRIb29rc30gaG9va3MgbW9kdWxlIGhvb2tzIGZvciB0aGUgdGVzdCBjb250ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgc2VydmljZVxuICogQHBhcmFtIHtvYmplY3R9IHN0dWIgdGhlIG92ZXJyaWRlcyB0byBhcHBseSB0byB0aGUgc2VydmljZVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwU2VydmljZVN0dWIoXG4gIGhvb2tzOiBOZXN0ZWRIb29rcyxcbiAgbmFtZTogc3RyaW5nLFxuICBzdHViOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4pOiB2b2lkIHtcbiAgbGV0IHNlcnZpY2VOYW1lID0gYHNlcnZpY2U6JHtuYW1lfWA7XG4gIGxldCBvcmlnaW5hbHM6IGFueSA9IHt9O1xuXG4gIGhvb2tzLmJlZm9yZUVhY2goZnVuY3Rpb24oKTogdm9pZCB7XG4gICAgbGV0IHsgb3duZXIgfSA9IGdldENvbnRleHQoKSBhcyBDb250ZXh0O1xuICAgIGxldCBzZXJ2aWNlID0gb3duZXIubG9va3VwKHNlcnZpY2VOYW1lKTtcblxuICAgIGlmICghc2VydmljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgc2VydmljZSAnJHtuYW1lfScgd2FzIG5vdCByZWdpc3RlcmVkLiBZb3UgZG8gbm90IG5lZWQgc2V0dXBTZXJ2aWNlU3R1YmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHByb3BlcnRpZXNBbmRNZXRob2RzID0gT2JqZWN0LmtleXMoc3R1Yik7XG5cbiAgICBwcm9wZXJ0aWVzQW5kTWV0aG9kcy5mb3JFYWNoKCgga2V5ICk6IHZvaWQgPT4ge1xuICAgICAgb3JpZ2luYWxzW2tleV0gPSBzZXJ2aWNlW2tleV07XG5cbiAgICAgIHNlcnZpY2Vba2V5XSA9IHN0dWJba2V5XTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgaG9va3MuYWZ0ZXJFYWNoKGZ1bmN0aW9uKCk6IHZvaWQge1xuICAgIGxldCB7IG93bmVyIH0gPSBnZXRDb250ZXh0KCkgYXMgQ29udGV4dDtcbiAgICBsZXQgc2VydmljZSA9IG93bmVyLmxvb2t1cChzZXJ2aWNlTmFtZSk7XG5cbiAgICBsZXQgcHJvcGVydGllc0FuZE1ldGhvZHMgPSBPYmplY3Qua2V5cyhzdHViKTtcblxuICAgIHByb3BlcnRpZXNBbmRNZXRob2RzLmZvckVhY2goKCBrZXkgKTogdm9pZCA9PiB7XG4gICAgICBzZXJ2aWNlW2tleV0gPSBvcmlnaW5hbHNba2V5XTtcbiAgICB9KTtcbiAgfSk7XG59XG4iXX0=